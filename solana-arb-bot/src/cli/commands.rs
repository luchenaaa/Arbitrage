use anyhow::{anyhow, Result};
use solana_client::rpc_client::RpcClient;
use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::time::Duration;

use crate::arbitrage::ArbitrageDetector;
use crate::bot::{BotController, SessionState};
use crate::config::Settings;
use crate::pools::detector::PoolDetector;

/// Default config template
const CONFIG_TEMPLATE: &str = r#"# Solana Arbitrage Bot Configuration
# Generated by: arb-bot init

[wallet]
# Option 1: Path to your Solana keypair JSON file
keypair_path = ""
# Option 2: Base58 encoded private key (use this OR keypair_path)
private_key = "YOUR_BASE58_PRIVATE_KEY"

[rpc]
# Standard RPC endpoint for queries (get_account, get_balance, etc.)
# Use a reliable RPC provider (Helius, Triton, QuickNode, etc.)
# DO NOT use Astralane endpoint here - it's only for transaction submission
endpoint = "https://api.mainnet-beta.solana.com"
# Request timeout in seconds
timeout_secs = 30

[pools]
# Up to 5 pool addresses (PumpSwap, DLMM, DAMM V2, CPMM, or Orca Whirlpool)
# The bot will find the best arbitrage opportunity across all pools
# Add 2-5 pool addresses below (uncomment and replace placeholders)
addresses = [
    "POOL_ADDRESS_1",
    "POOL_ADDRESS_2",
]
# Additional pools (copy and add to array above):
# "POOL_ADDRESS_3"
# "POOL_ADDRESS_4"
# "POOL_ADDRESS_5"
# The token you're arbitraging (must exist in all pools)
target_token = "TOKEN_MINT_ADDRESS"

[limits]
# Stop after this many trades
max_trade_count = 1000
# Maximum SOL to spend per trade
max_buy_amount_sol = 0.5
# Stop and emergency sell if losses exceed this
max_loss_sol = 2.0
# Minimum profit required to execute (after fees)
min_profit_sol = 0.001

[sizing]
# Don't take more than X% of pool liquidity per trade
max_pool_liquidity_percent = 2.0

[slippage]
# Slippage tolerance in basis points (100 = 1%)
buy_slippage_bps = 100
sell_slippage_bps = 100
# Higher slippage for emergency sells
emergency_slippage_bps = 1000

[fees]
# Priority fee in lamports
base_priority_lamports = 10000
# Jito/Astralane tip in lamports (min 10000)
jito_tip_lamports = 10000

[retry]
# Number of retry attempts if tx fails to land
max_retries = 3
# Multiply tip by this on each retry
tip_multiplier = 1.5
# Maximum tip (won't exceed this)
max_tip_lamports = 100000
# Delay between retries in ms
retry_delay_ms = 200

[safety]
# Trigger emergency sell if any pool price drops by this %
emergency_drop_percent = 50.0
# How often to check for opportunities (ms)
check_interval_ms = 100

[astralane]
# Astralane endpoint (Amsterdam recommended for EU, or use other regions)
# Options: ams.gateway.astralane.io, fr.gateway.astralane.io, ny.gateway.astralane.io, etc.
endpoint = "https://ams.gateway.astralane.io/iris"
# Your Astralane API key (get from https://astralane.io)
api_key = "YOUR_ASTRALANE_API_KEY"
# Tip wallet addresses - bot will randomly select one for each transaction
# All 8 official Astralane tip wallets for better load distribution
tip_wallets = [
    "astrazznxsGUhWShqgNtAdfrzP2G83DzcWVJDxwV9bF",
    "astra4uejePWneqNaJKuFFA8oonqCE1sqF6b45kDMZm",
    "astra9xWY93QyfG6yM8zwsKsRodscjQ2uU2HKNL5prk",
    "astraRVUuTHjpwEVvNBeQEgwYx9w9CFyfxjYoobCZhL",
    "astraEJ2fEj8Xmy6KLG7B3VfbKfsHXhHrNdCQx7iGJK",
    "astraubkDw81n4LuutzSQ8uzHCv4BhPVhfvTcYv8SKC",
    "astraZW5GLFefxNPAatceHhYjfA1ciq9gvfEg2S47xk",
    "astrawVNP4xDBKT7rAdxrLYiTSTdqtUr63fSMduivXK",
]

[grpc]
# Yellowstone gRPC endpoint for real-time updates (fastest option)
# Providers: Triton, Chainstack, Helius, etc.
# Leave empty to use WebSocket or RPC polling instead
endpoint = ""
# Authentication token (x-token header)
x_token = ""
# Auto-reconnect on connection loss
reconnect_enabled = true
# Maximum reconnection attempts before giving up
max_reconnect_attempts = 10
# WebSocket endpoint (alternative to gRPC, uses accountSubscribe)
# Used when gRPC endpoint is empty
ws_endpoint = ""

[logging]
# Trade history log file (JSONL format)
trade_log_path = "logs/trades.jsonl"
# Session state file (for crash recovery)
session_path = "logs/session.json"
# Log level: trace, debug, info, warn, error
log_level = "info"
"#;

pub async fn init(output_path: &str, force: bool) -> Result<()> {
    let path = Path::new(output_path);
    
    // Check if file exists
    if path.exists() && !force {
        return Err(anyhow!(
            "Config file '{}' already exists. Use --force to overwrite.",
            output_path
        ));
    }
    
    // Create parent directories if needed
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() {
            std::fs::create_dir_all(parent)?;
        }
    }
    
    // Write config file
    let mut file = File::create(path)?;
    file.write_all(CONFIG_TEMPLATE.as_bytes())?;
    
    println!("‚úÖ Config file created: {}", output_path);
    println!();
    println!("Next steps:");
    println!("  1. Edit {} and fill in:", output_path);
    println!("     - Pool addresses (2-5 pools for the same token pair)");
    println!("     - Target token mint address");
    println!("     - Astralane API key");
    println!("     - (Optional) gRPC endpoint for faster updates");
    println!();
    println!("  2. Validate your pools:");
    println!("     arb-bot validate-pools -c {}", output_path);
    println!();
    println!("  3. Start the bot:");
    println!("     arb-bot start -c {}", output_path);
    
    Ok(())
}

pub async fn start(config_path: &str, fresh: bool) -> Result<()> {
    use solana_sdk::pubkey::Pubkey;
    use std::str::FromStr;
    use crate::token::precache_token_programs;

    tracing::info!("Loading config from: {}", config_path);

    let settings = Settings::load(config_path)?;
    tracing::info!("Config loaded successfully");

    // Parse target token
    let target_token = Pubkey::from_str(&settings.pools.target_token)
        .map_err(|_| anyhow!("Invalid target token address"))?;

    // Validate pools at startup
    tracing::info!("Validating pool addresses...");
    let rpc = RpcClient::new_with_timeout(
        settings.rpc.endpoint.clone(),
        Duration::from_secs(settings.rpc.timeout_secs),
    );

    let detector = PoolDetector::new();
    let validated_pools = detector
        .validate_pools(&rpc, &settings.pools.addresses)
        .await?;

    if validated_pools.is_empty() {
        return Err(anyhow!("No valid pools found. Bot cannot start."));
    }

    // Validate all pools contain the target token
    detector.validate_common_token(&validated_pools, &target_token)?;

    tracing::info!(
        "‚úÖ {} pools validated successfully",
        validated_pools.len()
    );
    for pool in &validated_pools {
        tracing::info!("  - {} ({:?})", pool.address, pool.pool_type);
    }

    // Check for pool pairs that may exceed transaction size limits
    // PumpSwap + DLMM is known to be too large (>1232 bytes)
    let mut size_warnings = Vec::new();
    for i in 0..validated_pools.len() {
        for j in (i + 1)..validated_pools.len() {
            let pool_a = &validated_pools[i];
            let pool_b = &validated_pools[j];
            
            let (fits, estimated) = ArbitrageDetector::estimate_transaction_size(
                pool_a.pool_type,
                pool_b.pool_type,
            );
            
            if !fits {
                size_warnings.push((
                    pool_a.pool_type,
                    pool_b.pool_type,
                    estimated,
                ));
            }
        }
    }
    
    // Check if ALT is needed and auto-create if missing
    let mut settings = settings; // Make mutable for ALT update
    if !size_warnings.is_empty() {
        tracing::warn!("‚ö†Ô∏è Some pool pairs may exceed Solana's 1232 byte transaction limit:");
        for (type_a, type_b, estimated) in &size_warnings {
            tracing::warn!(
                "   {:?} + {:?} ‚âà {} bytes (limit: 1232)",
                type_a, type_b, estimated
            );
        }
        
        // Check if ALT is configured
        if settings.astralane.lookup_table.is_empty() {
            tracing::info!("üìã No ALT configured. Creating one automatically...");
            
            // Auto-create ALT
            match auto_create_alt(&rpc, &settings, config_path).await {
                Ok(alt_address) => {
                    tracing::info!("‚úÖ ALT created and saved to config: {}", alt_address);
                    settings.astralane.lookup_table = alt_address;
                }
                Err(e) => {
                    tracing::error!("‚ùå Failed to create ALT: {}", e);
                    tracing::warn!("   Large transactions will fail. Run 'arb-bot create-alt' manually.");
                }
            }
        } else {
            tracing::info!("üìã Using configured ALT: {}", settings.astralane.lookup_table);
        }
    }

    // Pre-cache token programs for all mints
    tracing::info!("Pre-caching token programs...");
    let mut mints_to_cache: Vec<Pubkey> = vec![target_token];
    for pool in &validated_pools {
        if let Some(mint) = pool.token_a_mint {
            if !mints_to_cache.contains(&mint) {
                mints_to_cache.push(mint);
            }
        }
        if let Some(mint) = pool.token_b_mint {
            if !mints_to_cache.contains(&mint) {
                mints_to_cache.push(mint);
            }
        }
    }
    precache_token_programs(&rpc, &mints_to_cache);
    tracing::info!("‚úÖ Cached {} token programs", mints_to_cache.len());

    if fresh {
        tracing::info!("Starting fresh session (ignoring previous state)");
    }

    // Create and run bot controller
    let mut controller = BotController::new(settings, validated_pools, fresh).await?;

    // Set up Ctrl+C handler
    let should_stop = controller.should_stop.clone();
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.ok();
        tracing::info!("üõë Ctrl+C received, stopping bot...");
        should_stop.store(true, std::sync::atomic::Ordering::Relaxed);
    });

    // Run the bot
    controller.run().await?;

    Ok(())
}

pub async fn status() -> Result<()> {
    // Read from session file
    let session = SessionState::load_or_create(Some("logs/session.json"));
    
    println!("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    println!("‚ïë                        BOT STATUS                                ‚ïë");
    println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
    println!("‚ïë  Session ID: {}...                                   ‚ïë", &session.session_id[..8]);
    println!("‚ïë  Started: {}                                  ‚ïë", session.started_at.format("%Y-%m-%d %H:%M:%S"));
    println!("‚ïë  Trade Count: {}                                               ‚ïë", session.trade_count);
    println!("‚ïë  P&L: {:.6} SOL                                            ‚ïë", session.total_pnl_sol);
    println!("‚ïë  Win Rate: {:.1}%                                              ‚ïë", session.win_rate());
    println!("‚ïë  Last Updated: {}                             ‚ïë", session.last_updated.format("%Y-%m-%d %H:%M:%S"));
    println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    Ok(())
}

pub async fn emergency_sell() -> Result<()> {
    tracing::warn!("üö® Emergency sell command");
    tracing::warn!("üö® This command requires the bot to be running.");
    tracing::warn!("üö® Use Ctrl+C to stop the bot gracefully, which will trigger emergency sell if needed.");
    Ok(())
}

pub async fn stop() -> Result<()> {
    tracing::info!("üõë Stop command");
    tracing::info!("üõë Use Ctrl+C in the running bot terminal to stop gracefully.");
    Ok(())
}

pub async fn history(last: usize) -> Result<()> {
    let log_path = "logs/trades.jsonl";
    
    let file = match File::open(log_path) {
        Ok(f) => f,
        Err(_) => {
            println!("No trade history found at {}", log_path);
            return Ok(());
        }
    };
    
    let reader = BufReader::new(file);
    let lines: Vec<String> = reader.lines().filter_map(|l| l.ok()).collect();
    
    let start = if lines.len() > last { lines.len() - last } else { 0 };
    
    println!("\n=== Last {} Trades ===\n", last.min(lines.len()));
    
    for line in &lines[start..] {
        if let Ok(trade) = serde_json::from_str::<serde_json::Value>(line) {
            let timestamp = trade.get("timestamp").and_then(|v| v.as_str()).unwrap_or("?");
            let trade_type = trade.get("trade_type").and_then(|v| v.as_str()).unwrap_or("?");
            let profit = trade.get("profit_sol").and_then(|v| v.as_f64()).unwrap_or(0.0);
            let status = trade.get("status").and_then(|v| v.as_str()).unwrap_or("?");
            let sig = trade.get("tx_sig").and_then(|v| v.as_str()).unwrap_or("?");
            
            let profit_str = if profit >= 0.0 {
                format!("+{:.6}", profit)
            } else {
                format!("{:.6}", profit)
            };
            
            println!(
                "{} | {} | {} SOL | {} | {}...",
                timestamp,
                trade_type,
                profit_str,
                status,
                &sig[..8.min(sig.len())]
            );
        }
    }
    
    println!("\nTotal trades in history: {}", lines.len());
    
    Ok(())
}

pub async fn validate_pools(config_path: &str) -> Result<()> {
    use solana_sdk::pubkey::Pubkey;
    use std::str::FromStr;

    tracing::info!("Loading config from: {}", config_path);

    let settings = Settings::load(config_path)?;

    let rpc = RpcClient::new_with_timeout(
        settings.rpc.endpoint.clone(),
        Duration::from_secs(settings.rpc.timeout_secs),
    );

    tracing::info!(
        "Validating {} pool addresses...",
        settings.pools.addresses.len()
    );

    let detector = PoolDetector::new();
    let validated_pools = detector
        .validate_pools(&rpc, &settings.pools.addresses)
        .await?;

    println!("\n=== Pool Validation Results ===\n");

    for pool in &validated_pools {
        println!("‚úÖ {} - {:?}", pool.address, pool.pool_type);
        if let (Some(a), Some(b)) = (pool.token_a_mint, pool.token_b_mint) {
            println!("   Token A: {}", a);
            println!("   Token B: {}", b);
        }
    }

    let invalid_count = settings.pools.addresses.len() - validated_pools.len();
    if invalid_count > 0 {
        println!("\n‚ùå {} pools were invalid or unsupported", invalid_count);
    }

    // Check if all pools contain the target token
    let target_token = Pubkey::from_str(&settings.pools.target_token)
        .map_err(|_| anyhow!("Invalid target token address"))?;

    println!("\n=== Target Token Check ===\n");
    println!("Target token: {}", target_token);

    match detector.validate_common_token(&validated_pools, &target_token) {
        Ok(()) => {
            println!("‚úÖ All pools contain the target token");
        }
        Err(e) => {
            println!("‚ùå {}", e);
        }
    }

    println!("\nTotal valid pools: {}", validated_pools.len());

    Ok(())
}

/// Create an Address Lookup Table (ALT) for transaction size optimization
pub async fn create_alt(config_path: &str) -> Result<()> {
    use solana_sdk::{
        address_lookup_table::instruction as alt_instruction,
        pubkey::Pubkey,
        signature::{EncodableKey, Keypair},
        signer::Signer,
        transaction::Transaction,
    };
    use std::str::FromStr;

    tracing::info!("Loading config from: {}", config_path);
    let settings = Settings::load(config_path)?;

    // Load wallet
    let wallet = if !settings.wallet.private_key.is_empty() {
        let secret_bytes = bs58::decode(&settings.wallet.private_key)
            .into_vec()
            .map_err(|e| anyhow!("Invalid base58 private key: {}", e))?;
        Keypair::from_bytes(&secret_bytes)
            .map_err(|e| anyhow!("Invalid private key bytes: {}", e))?
    } else {
        let keypair_path = shellexpand::tilde(&settings.wallet.keypair_path).to_string();
        Keypair::read_from_file(&keypair_path)
            .map_err(|e| anyhow!("Failed to load wallet from file: {}", e))?
    };

    let rpc = RpcClient::new_with_timeout(
        settings.rpc.endpoint.clone(),
        Duration::from_secs(settings.rpc.timeout_secs),
    );

    println!("\n=== Creating Address Lookup Table ===\n");
    println!("Wallet: {}", wallet.pubkey());

    // Get recent slot for ALT creation
    let slot = rpc.get_slot()?;
    
    // Create ALT instruction
    let (create_ix, alt_address) = alt_instruction::create_lookup_table(
        wallet.pubkey(),
        wallet.pubkey(),
        slot,
    );

    println!("ALT Address: {}", alt_address);
    println!("Creating ALT...");

    // Build and send transaction
    let blockhash = rpc.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &[create_ix],
        Some(&wallet.pubkey()),
        &[&wallet],
        blockhash,
    );

    let sig = rpc.send_and_confirm_transaction(&tx)?;
    println!("‚úÖ ALT created! Signature: {}", sig);

    // Collect addresses to add to ALT
    let addresses = collect_alt_addresses(&settings)?;
    
    println!("\nExtending ALT with {} addresses...", addresses.len());

    // Extend ALT with addresses (max 30 per tx)
    for chunk in addresses.chunks(30) {
        let extend_ix = alt_instruction::extend_lookup_table(
            alt_address,
            wallet.pubkey(),
            Some(wallet.pubkey()),
            chunk.to_vec(),
        );

        let blockhash = rpc.get_latest_blockhash()?;
        let tx = Transaction::new_signed_with_payer(
            &[extend_ix],
            Some(&wallet.pubkey()),
            &[&wallet],
            blockhash,
        );

        let sig = rpc.send_and_confirm_transaction(&tx)?;
        println!("  Added {} addresses, sig: {}", chunk.len(), sig);
    }

    println!("\n‚úÖ ALT setup complete!");
    println!("\nAdd this to your config.toml under [astralane]:");
    println!("lookup_table = \"{}\"", alt_address);
    
    // Record ALT to history file
    record_alt_to_history(&settings.pools.target_token, &alt_address.to_string());

    Ok(())
}

/// Extend an existing ALT with more addresses
pub async fn extend_alt(config_path: &str, alt_address_str: &str) -> Result<()> {
    use solana_sdk::{
        address_lookup_table::instruction as alt_instruction,
        pubkey::Pubkey,
        signature::{EncodableKey, Keypair},
        signer::Signer,
        transaction::Transaction,
    };
    use std::str::FromStr;

    tracing::info!("Loading config from: {}", config_path);
    let settings = Settings::load(config_path)?;

    let alt_address = Pubkey::from_str(alt_address_str)
        .map_err(|e| anyhow!("Invalid ALT address: {}", e))?;

    // Load wallet
    let wallet = if !settings.wallet.private_key.is_empty() {
        let secret_bytes = bs58::decode(&settings.wallet.private_key)
            .into_vec()
            .map_err(|e| anyhow!("Invalid base58 private key: {}", e))?;
        Keypair::from_bytes(&secret_bytes)
            .map_err(|e| anyhow!("Invalid private key bytes: {}", e))?
    } else {
        let keypair_path = shellexpand::tilde(&settings.wallet.keypair_path).to_string();
        Keypair::read_from_file(&keypair_path)
            .map_err(|e| anyhow!("Failed to load wallet from file: {}", e))?
    };

    let rpc = RpcClient::new_with_timeout(
        settings.rpc.endpoint.clone(),
        Duration::from_secs(settings.rpc.timeout_secs),
    );

    println!("\n=== Extending Address Lookup Table ===\n");
    println!("ALT: {}", alt_address);
    println!("Wallet: {}", wallet.pubkey());

    // Get existing addresses in ALT
    let alt_account = rpc.get_account(&alt_address)?;
    let existing_addresses = parse_alt_addresses(&alt_account.data)?;
    println!("Existing addresses in ALT: {}", existing_addresses.len());

    // Collect all addresses we want
    let all_addresses = collect_alt_addresses(&settings)?;
    
    // Filter out addresses already in ALT
    let new_addresses: Vec<Pubkey> = all_addresses
        .into_iter()
        .filter(|addr| !existing_addresses.contains(addr))
        .collect();

    if new_addresses.is_empty() {
        println!("‚úÖ ALT already contains all required addresses!");
        return Ok(());
    }

    println!("Adding {} new addresses...", new_addresses.len());

    // Extend ALT with new addresses (max 30 per tx)
    for chunk in new_addresses.chunks(30) {
        let extend_ix = alt_instruction::extend_lookup_table(
            alt_address,
            wallet.pubkey(),
            Some(wallet.pubkey()),
            chunk.to_vec(),
        );

        let blockhash = rpc.get_latest_blockhash()?;
        let tx = Transaction::new_signed_with_payer(
            &[extend_ix],
            Some(&wallet.pubkey()),
            &[&wallet],
            blockhash,
        );

        let sig = rpc.send_and_confirm_transaction(&tx)?;
        println!("  Added {} addresses, sig: {}", chunk.len(), sig);
    }

    println!("\n‚úÖ ALT extended successfully!");

    Ok(())
}

/// Collect all addresses that should be in the ALT
fn collect_alt_addresses(settings: &Settings) -> Result<Vec<solana_sdk::pubkey::Pubkey>> {
    use solana_sdk::{pubkey::Pubkey, signature::{EncodableKey, Keypair}, signer::Signer};
    use std::str::FromStr;

    let mut addresses = Vec::new();

    // Common program IDs
    let common_programs = [
        // System & Token programs
        "11111111111111111111111111111111",                      // System Program
        "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",          // Token Program
        "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",          // Token-2022
        "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL",         // Associated Token Program
        "ComputeBudget111111111111111111111111111111",           // Compute Budget
        
        // PumpSwap
        "pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA",          // PumpSwap Program
        "pfeeUxB6jkeY1Hxd7CsFCAjcbHA9rWtchMGdZ6VojVZ",          // PumpSwap Fee Program
        "ADyA8hdefvWN2dbGGWFotbzWxrAvLW83WG6QCVXvJKqw",         // PumpSwap Global
        "GS4CU59F31iL7aR2Q8zVS8DRrcRnXX1yjQ66TqNVQnaR",         // PumpSwap Event Authority
        "62qc2CNXwrYqQScmEdiZFFAnJR262PxWEuNQtxfafNgV",         // PumpSwap Fee Recipient
        "C2aFPdENg4A2HQsmrd5rTw5TaYBX5Ku887cWjbFKtZpw",         // PumpSwap Global Volume
        "5PHirr8joyTMp9JMm6nW7hNDVyEYdkzDqazxPD7RaTjx",         // PumpSwap Fee Config
        
        // Meteora DLMM
        "LBUZKhRxPF3XUpBCjp4YzTKgLccjZhTSDM9YuVaPwxo",          // DLMM Program
        "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr",          // Memo Program
        
        // WSOL
        "So11111111111111111111111111111111111111112",           // WSOL Mint
    ];

    for addr_str in &common_programs {
        if let Ok(pubkey) = Pubkey::from_str(addr_str) {
            addresses.push(pubkey);
        }
    }

    // Add target token mint
    if let Ok(target) = Pubkey::from_str(&settings.pools.target_token) {
        addresses.push(target);
    }

    // NOTE: Do NOT add Astralane tip wallets to ALT!
    // Astralane needs to see the full 32-byte tip wallet address to detect the tip.
    // If tip wallets are in ALT, they get compressed to 1-byte indices and
    // Astralane returns "transaction tip [0] is less than min tip [10000]"

    // Add wallet pubkey
    let wallet_pubkey = if !settings.wallet.private_key.is_empty() {
        let secret_bytes = bs58::decode(&settings.wallet.private_key)
            .into_vec()
            .map_err(|e| anyhow!("Invalid base58 private key: {}", e))?;
        Keypair::from_bytes(&secret_bytes)
            .map_err(|e| anyhow!("Invalid private key bytes: {}", e))?
            .pubkey()
    } else {
        let keypair_path = shellexpand::tilde(&settings.wallet.keypair_path).to_string();
        Keypair::read_from_file(&keypair_path)
            .map_err(|e| anyhow!("Failed to load wallet from file: {}", e))?
            .pubkey()
    };
    
    if !addresses.contains(&wallet_pubkey) {
        addresses.push(wallet_pubkey);
    }

    Ok(addresses)
}

/// Parse addresses from ALT account data
fn parse_alt_addresses(data: &[u8]) -> Result<Vec<solana_sdk::pubkey::Pubkey>> {
    use solana_sdk::pubkey::Pubkey;

    const HEADER_SIZE: usize = 56;

    if data.len() < HEADER_SIZE {
        return Err(anyhow!("ALT account data too small"));
    }

    let addresses_data = &data[HEADER_SIZE..];
    let num_addresses = addresses_data.len() / 32;

    let mut addresses = Vec::with_capacity(num_addresses);
    for i in 0..num_addresses {
        let start = i * 32;
        let end = start + 32;
        if end > addresses_data.len() {
            break;
        }
        let pubkey = Pubkey::try_from(&addresses_data[start..end])
            .map_err(|_| anyhow!("Invalid pubkey in ALT at index {}", i))?;
        addresses.push(pubkey);
    }

    Ok(addresses)
}


/// Auto-create ALT and save address to config.toml
async fn auto_create_alt(rpc: &RpcClient, settings: &Settings, config_path: &str) -> Result<String> {
    use solana_sdk::{
        address_lookup_table::instruction as alt_instruction,
        pubkey::Pubkey,
        signature::{EncodableKey, Keypair},
        signer::Signer,
        transaction::Transaction,
    };

    // Load wallet
    let wallet = if !settings.wallet.private_key.is_empty() {
        let secret_bytes = bs58::decode(&settings.wallet.private_key)
            .into_vec()
            .map_err(|e| anyhow!("Invalid base58 private key: {}", e))?;
        Keypair::from_bytes(&secret_bytes)
            .map_err(|e| anyhow!("Invalid private key bytes: {}", e))?
    } else {
        let keypair_path = shellexpand::tilde(&settings.wallet.keypair_path).to_string();
        Keypair::read_from_file(&keypair_path)
            .map_err(|e| anyhow!("Failed to load wallet from file: {}", e))?
    };

    tracing::info!("Creating ALT with wallet: {}", wallet.pubkey());

    // Get recent slot for ALT creation
    let slot = rpc.get_slot()?;
    
    // Create ALT instruction
    let (create_ix, alt_address) = alt_instruction::create_lookup_table(
        wallet.pubkey(),
        wallet.pubkey(),
        slot,
    );

    tracing::info!("ALT address will be: {}", alt_address);

    // Build and send create transaction
    let blockhash = rpc.get_latest_blockhash()?;
    let tx = Transaction::new_signed_with_payer(
        &[create_ix],
        Some(&wallet.pubkey()),
        &[&wallet],
        blockhash,
    );

    let sig = rpc.send_and_confirm_transaction(&tx)
        .map_err(|e| anyhow!("Failed to create ALT: {}", e))?;
    tracing::info!("ALT created, signature: {}", sig);

    // Collect addresses to add to ALT
    let addresses = collect_alt_addresses(settings)?;
    tracing::info!("Adding {} addresses to ALT...", addresses.len());

    // Extend ALT with addresses (max 30 per tx)
    for (i, chunk) in addresses.chunks(30).enumerate() {
        let extend_ix = alt_instruction::extend_lookup_table(
            alt_address,
            wallet.pubkey(),
            Some(wallet.pubkey()),
            chunk.to_vec(),
        );

        let blockhash = rpc.get_latest_blockhash()?;
        let tx = Transaction::new_signed_with_payer(
            &[extend_ix],
            Some(&wallet.pubkey()),
            &[&wallet],
            blockhash,
        );

        rpc.send_and_confirm_transaction(&tx)
            .map_err(|e| anyhow!("Failed to extend ALT (batch {}): {}", i, e))?;
        tracing::debug!("Added batch {} ({} addresses)", i + 1, chunk.len());
    }

    // Save ALT address to config.toml
    save_alt_to_config(config_path, &alt_address.to_string())?;
    
    // Record ALT to history file (non-blocking, won't affect trading speed)
    record_alt_to_history(&settings.pools.target_token, &alt_address.to_string());

    Ok(alt_address.to_string())
}

/// Save ALT address to config.toml
fn save_alt_to_config(config_path: &str, alt_address: &str) -> Result<()> {
    use std::fs;

    let content = fs::read_to_string(config_path)
        .map_err(|e| anyhow!("Failed to read config file: {}", e))?;

    let new_line = format!("lookup_table = \"{}\"", alt_address);
    
    let new_content = if content.contains("lookup_table") {
        // Replace existing lookup_table line
        let lines: Vec<String> = content
            .lines()
            .map(|line| {
                if line.trim().starts_with("lookup_table") {
                    new_line.clone()
                } else {
                    line.to_string()
                }
            })
            .collect();
        lines.join("\n")
    } else if content.contains("[astralane]") {
        // Add lookup_table after [astralane] section
        content.replace(
            "[astralane]",
            &format!("[astralane]\n# Auto-generated Address Lookup Table for transaction size optimization\n{}", new_line)
        )
    } else {
        // Append to end
        format!("{}\n\n# Auto-generated Address Lookup Table\n[astralane]\n{}\n", content, new_line)
    };

    fs::write(config_path, new_content)
        .map_err(|e| anyhow!("Failed to write config file: {}", e))?;

    tracing::info!("‚úÖ ALT address saved to {}", config_path);
    Ok(())
}

/// Record ALT creation to history JSON file
/// This runs asynchronously and doesn't block trading
fn record_alt_to_history(target_token: &str, alt_address: &str) {
    use std::fs::{self, OpenOptions};
    use std::io::Write;
    
    const ALT_HISTORY_FILE: &str = "logs/alt_history.json";
    
    // Create logs directory if needed
    if let Err(e) = fs::create_dir_all("logs") {
        tracing::warn!("Failed to create logs directory: {}", e);
        return;
    }
    
    // Read existing history or create new
    let mut history: Vec<serde_json::Value> = match fs::read_to_string(ALT_HISTORY_FILE) {
        Ok(content) => serde_json::from_str(&content).unwrap_or_default(),
        Err(_) => Vec::new(),
    };
    
    // Add new entry
    let entry = serde_json::json!({
        "target_token": target_token,
        "lookup_table": alt_address,
        "created_at": chrono::Utc::now().to_rfc3339()
    });
    history.push(entry);
    
    // Write back to file
    match serde_json::to_string_pretty(&history) {
        Ok(json) => {
            if let Err(e) = fs::write(ALT_HISTORY_FILE, json) {
                tracing::warn!("Failed to write ALT history: {}", e);
            } else {
                tracing::debug!("üìã ALT recorded to {}", ALT_HISTORY_FILE);
            }
        }
        Err(e) => {
            tracing::warn!("Failed to serialize ALT history: {}", e);
        }
    }
}
